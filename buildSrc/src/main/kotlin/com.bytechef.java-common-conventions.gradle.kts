import org.gradle.api.tasks.testing.logging.TestExceptionFormat

/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    checkstyle
    id("com.diffplug.spotless")
    id("com.github.spotbugs")
    idea
    jacoco
    java
    `maven-publish`
    pmd
}


val check by tasks.existing

//https://melix.github.io/blog/2021/03/version-catalogs-faq.html#_can_i_use_the_version_catalog_in_buildsrc
val libs = rootProject.extensions.getByType<VersionCatalogsExtension>().named("libs")

checkstyle {
    toolVersion = "${libs.findVersion("checkstyle").get()}"
    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
}

val cleanResources by tasks.registering(Delete::class) {
    delete("build/resources")
}

val compileJava by tasks.existing(JavaCompile::class) {
    options.compilerArgs.add("-parameters")
}

idea {
    module {
        excludeDirs.addAll(files("node_modules"))
        sourceDirs.add(file("build/generated/sources/annotationProcessor/java/main"))
        generatedSourceDirs.add(file("build/generated/sources/annotationProcessor/java/main"))
    }
}

jacoco {
    toolVersion = "${libs.findVersion("jacoco").get()}"
}

tasks.withType(JacocoReport::class) {
    executionData(tasks.withType(Test::class))
    classDirectories.setFrom(sourceSets.main.get().output.classesDirs)
    sourceDirectories.setFrom(sourceSets.main.get().java.srcDirs)

    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of("${libs.findVersion("java").get()}"))
    }
}

pmd {
    toolVersion = "${libs.findVersion("pmd").get()}"
    ruleSetFiles = files("${rootDir}/config/pmd/pmd-ruleset.xml")
    ruleSets()
}

publishing {
    publications {
        create<MavenPublication>("maven") {
            from(components["java"])
        }
    }
}

repositories {
    mavenLocal()

    mavenCentral()

    maven {
        url = uri("https://repo.spring.io/release")
    }
}

spotbugs {
    toolVersion.set("${libs.findVersion("spotbugs").get()}")
    reportsDir.set(file("${layout.buildDirectory.get()}/reports/spotbugs"))
    excludeFilter.set(file("${rootDir}/config/spotbugs/spotbugs-exclude.xml"))

    tasks.spotbugsMain {
        reports.create("html") {
            enabled = true
            setStylesheet("fancy-hist.xsl")
        }
    }
    tasks.spotbugsTest {
        reports.create("html") {
            enabled = true
            setStylesheet("fancy-hist.xsl")
        }
    }
}

spotless {
    format("misc") {
        // define the files to apply `misc` to
        target("*.gradle", "*.md", ".gitignore")

        trimTrailingWhitespace()
        indentWithSpaces(4)
        endWithNewline()
    }
    java {
        target("src/*/java/**/*.java")

        licenseHeader(
            """
            /*
             * Copyright 2023-present ByteChef Inc.
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      https://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            """
        ).named(
            "standard"
        )
        licenseHeader(
            """
            /*
             * Copyright 2016-2020 the original author or authors.
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *      https://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             *
             * Modifications copyright (C) 2023 ByteChef Inc.
             */
            """
        ).named(
            "original"
        ).onlyIfContentMatches(
            "author\\sArik\\sCohen"
        )
        eclipse().configFile("$rootDir/config/eclipse/eclipse-code-formatter-settings.xml")
        removeUnusedImports()
        trimTrailingWhitespace()
        indentWithSpaces(4)
        endWithNewline()
    }
    java {
        target("ee/**/src/*/java/**/*.java")

        licenseHeader(
            """
            /**
             * The ByteChef Enterprise license (the "Enterprise License")
             * Copyright (c) 2023 - present ByteChef Inc.
             *
             * With regard to the ByteChef Software:
             *
             * This software and associated documentation files (the "Software") may only be
             * used in production, if you (and any entity that you represent) have agreed to,
             * and are in compliance with, the ByteChef Subscription Terms of Service, available
             * via email (support@bytechef.io) (the "Enterprise Terms"), or other
             * agreement governing the use of the Software, as agreed by you and ByteChef,
             * and otherwise have a valid ByteChef Enterprise license for the
             * correct number of user seats. Subject to the foregoing sentence, you are free to
             * modify this Software and publish patches to the Software. You agree that ByteChef
             * and/or its licensors (as applicable) retain all right, title and interest in and
             * to all such modifications and/or patches, and all such modifications and/or
             * patches may only be used, copied, modified, displayed, distributed, or otherwise
             * exploited with a valid ByteChef Enterprise license for the  correct
             * number of user seats.  Notwithstanding the foregoing, you may copy and modify
             * the Software for development and testing purposes, without requiring a
             * subscription.  You agree that ByteChef and/or its licensors (as applicable) retain
             * all right, title and interest in and to all such modifications.  You are not
             * granted any other rights beyond what is expressly stated herein.  Subject to the
             * foregoing, it is forbidden to copy, merge, publish, distribute, sublicense,
             * and/or sell the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
             * SOFTWARE.
             *
             * For all third party components incorporated into the ByteChef Software, those
             * components are licensed under the original license provided by the owner of the
             * applicable component.
             */
            """)
    }
    yaml {
        target("cli/**/src/**/*.yaml", "server/**/src/**/*.yaml")
        jackson()
    }
    json {
        target("cli/**/src/**/*.json", "server/**/src/**/*.json")
        jackson()
    }
}

val spotlessCheck by tasks.existing

check {
    dependsOn(spotlessCheck)
}

val test by tasks.existing(Test::class) {
    useJUnitPlatform()
    exclude("**/*IntTest*")
    testLogging {
        events("standardOut", "skipped", "failed")
        showExceptions = true
        exceptionFormat = TestExceptionFormat.FULL
        showCauses = true
        showStackTraces = true
    }
    jvmArgs("-Djava.security.egd=file:/dev/./urandom -Xmx256m")
    // uncomment if the tests reports are not generated
    // ignoreFailures = true
    reports.html.required.set(true)

    addTestListener(object : TestListener {
        override fun beforeSuite(suite: TestDescriptor) {}
        override fun beforeTest(testDescriptor: TestDescriptor) {}
        override fun afterTest(testDescriptor: TestDescriptor, result: TestResult) {}
        override fun afterSuite(suite: TestDescriptor, result: TestResult) {
            if (suite.parent == null) { // will match the outermost suite
                val output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                val startItem = "|  "
                val endItem = "  |"
//                val repeatLength = startItem.length + output.length + endItem.length
//                println("\n" + ('-' * repeatLength) + "\n" + startItem + output + endItem + "\n" + ("-" * repeatLength))
                println("\n" + "\n" + startItem + output + endItem + "\n")
            }
        }
    })
}

val testIntegration by tasks.registering(Test::class) {
    useJUnitPlatform()
    description = "Execute integration tests."
    group = "verification"
    include("**/*IntTest*")
    testLogging {
        events("standardOut", "skipped", "failed")
        showExceptions = true
        exceptionFormat = TestExceptionFormat.FULL
        showCauses = true
        showStackTraces = true
    }
    jvmArgs("-Djava.security.egd=file:/dev/./urandom -Xmx256m")

    environment["spring.profiles.active"] = "testint"

    // uncomment if the tests reports are not generated
    // ignoreFailures = true
    reports.html.required.set(true)

    addTestListener(object : TestListener {
        override fun beforeSuite(suite: TestDescriptor) {}
        override fun beforeTest(testDescriptor: TestDescriptor) {}
        override fun afterTest(testDescriptor: TestDescriptor, result: TestResult) {}
        override fun afterSuite(suite: TestDescriptor, result: TestResult) {
            if (suite.parent == null) { // will match the outermost suite
                val output =
                    "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                val startItem = "|  "
                val endItem = "  |"
//                val repeatLength = startItem.length + output.length + endItem.length
//                println("\n" + ('-' * repeatLength) + "\n" + startItem + output + endItem + "\n" + ("-" * repeatLength))
                println("\n" + "\n" + startItem + output + endItem + "\n")
            }
        }
    })
}

check {
    dependsOn(testIntegration)
}

testing {
    suites {
        // Configure the built-in test suite
        val test by getting(JvmTestSuite::class) {
            // Use JUnit Jupiter test framework
            useJUnitJupiter("5.10.0")
        }
    }
}

val testReport by tasks.registering(TestReport::class) {
    destinationDirectory.set(file("${layout.buildDirectory.get()}/reports/tests"))
    testResults.from(test)
}

val testIntegrationReport by tasks.registering(TestReport::class) {
    destinationDirectory.set(file("${layout.buildDirectory.get()}/reports/tests"))
    testResults.from(testIntegration)
}
